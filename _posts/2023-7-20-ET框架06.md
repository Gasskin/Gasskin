---
title: "ET|06 Protobuf与网络通讯"
tags: 服务器
---

# Protobuf

## 序列化/反序列化

- 序列化 ：Class实例对象 >>> byte、xml、json等
- 反序列化 ：byte、xml、json等 >>> Class实例对象

序列化的好处有很多，比如可以存到硬盘，比如可以压缩数据等等

## Protobuf

类似于json的一种序列化格式，可以做到数据压缩更小，反序列化速度更快

是谷歌开源的一种数据存储格式，需要我们定义好Proto描述文件，然后通过谷歌提供的对应的代码生成工具，生成对于语言的代码

![image-20230730190148723](https://cdn.jsdelivr.net/gh/Gasskin/CloudImg/img202307301901838.png)

> 工程内的Proto描述文件，位于./Proto中

- **OuterMessage** 客户端与服务端通信
- **InnerMessage** 服务器之间进行通讯
- **MongoMessage** 服务器之间进行通讯，但可以传送Entity

打开InnerMessage.proto，可以看见头两行有一个定义

```protobuf
syntax = "proto3";
package ET;
```

语法是Proto3（注意，不同版本的Proto语法是不一样的）

第二行就是一个命名空间了

尝试写一个测试消息

```protobuf
message C2M_Test
{
	int32 RpcId = 90,
	string test = 1
}
```

然后运行文件夹下的bat生成文件

然后可以在此处找到对应的生成代码

![image-20230730192809109](https://cdn.jsdelivr.net/gh/Gasskin/CloudImg/img202307301928138.png)

```c#
[ResponseType(nameof(M2C_TestResponse))]
[Message(OuterOpcode.C2M_TestRequest)]
[ProtoContract]
public partial class C2M_TestRequest: Object, IActorLocationRequest
{
   [ProtoMember(90)]
   public int RpcId { get; set; }

   [ProtoMember(1)]
   public string request { get; set; }

}

[Message(OuterOpcode.M2C_TestResponse)]
[ProtoContract]
public partial class M2C_TestResponse: Object, IActorLocationResponse
{
   [ProtoMember(90)]
   public int RpcId { get; set; }

   [ProtoMember(91)]
   public int Error { get; set; }

   [ProtoMember(92)]
   public string Message { get; set; }

   [ProtoMember(1)]
   public string response { get; set; }

}
```

会生成2个结构，C2S以及S2C的

注意，ET中的proto生成器，并非谷歌提供的版本，而是ET项目自己提供的

![image-20230730192930741](https://cdn.jsdelivr.net/gh/Gasskin/CloudImg/img202307301929764.png)

# 网络通讯

