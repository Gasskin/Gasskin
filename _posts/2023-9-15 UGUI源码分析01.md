---
title: "UGUI源码分析|01 EventSystem"
tags: UGUI
---

用于处理点击、键盘输入、触摸等事件，所以实际上仅仅只是**InputEventSystem**

EventSystem继承自UIBehaviour，而后者又继承自MonoBehaviour，所以EventSystem本质还是一个Mono

代码一开头，定义了两个输入模块

```c#
private List<BaseInputModule> m_SystemInputModules = new List<BaseInputModule>();
private BaseInputModule m_CurrentInputModule;
```

很明显，一个是所有的输入模块，一个是当前使用中的输入模块

在Update中会调用一个Tick方法，去更新所有的模块

```c#
private void TickModules()
{
    var systemInputModulesCount = m_SystemInputModules.Count;
    for (var i = 0; i < systemInputModulesCount; i++)
    {
        if (m_SystemInputModules[i] != null)
            m_SystemInputModules[i].UpdateModule();
    }
}
```

当前输入模块，最开始是null，会在Update的时候去判断用哪一个Module

```c#
for (var i = 0; i < systemInputModulesCount; i++)
{
    var module = m_SystemInputModules[i];
    if (module.IsModuleSupported() && module.ShouldActivateModule())
    {
        if (m_CurrentInputModule != module)
        {
            ChangeEventModule(module);
            changedModule = true;
        }
        break;
    }
}
```

实际上Module的继承关系有好几层，最终直接使用的有两种

- StandaloneInputModule 用于PC
- TouchInputModule 用于移动平台

上面两个都继承自PointerInputModule，而它最终继承自BaseInputModule

**RayCastAll**

```c#
public void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults)
{
    raycastResults.Clear();
    var modules = RaycasterManager.GetRaycasters();
    var modulesCount = modules.Count;
    for (int i = 0; i < modulesCount; ++i)
    {
        var module = modules[i];
        if (module == null || !module.IsActive())
            continue;

        module.Raycast(eventData, raycastResults);
    }

    raycastResults.Sort(s_RaycastComparer);
}
```