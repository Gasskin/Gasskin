---
title: "重新认识Task"
tags: C#
---

经过一定时间的使用，对Task与异步编程有了更加清晰的认知，故翻新一篇新的文章作为记录

# 异步是如何生效的？

这一部分内容基本翻译自 [How Async/Await Really Works in C# - .NET Blog (microsoft.com)](https://devblogs.microsoft.com/dotnet/how-async-await-really-works/)

添加了一小部分个人理解

从一个简单的同步例子开始，一个拷贝字节流的同步方法

```c#
// Synchronously copy all data from source to destination.
public void CopyStreamToStream(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = source.Read(buffer, 0, buffer.Length)) != 0)
    {
        destination.Write(buffer, 0, numRead);
    }
}
```

这个方法没有任何问题，只不过在他彻底执行结束以前，程序不能做其他任何事情（阻塞）

而我们仅需要一丢丢的改动，就可以让这个方法不再阻塞

```c#
// Asynchronously copy all data from source to destination.
public async Task CopyStreamToStreamAsync(Stream source, Stream destination)
{
    var buffer = new byte[0x1000];
    int numRead;
    while ((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) != 0)
    {
        await destination.WriteAsync(buffer, 0, numRead);
    }
}
```

几乎没有改动，只是添加了几个关键字，这是因为所有繁重的工作都由编译器替我们做好了...

buy why？这一切是如何发生的？真的如此简单吗？

且听我慢慢道来...

## 基于Begin/End的异步

早在.Net Framework1.0时，就已经支持异步了，当时是一种Begin/End的模式

举个例子，对于一个同步方法

```c#
class Handler
{
    public int DoStuff(string arg);
}
```

如果想要修改为异步，那需要相应的Begin/End方法

```c#
class Handler:IAsyncResult
{
    public IAsyncResult BeginDoStuff(string arg, AsyncCallback? callback, object? state);
    public int EndDoStuff(IAsyncResult asyncResult);
}
```

 Begin方法包含原方法的输入参数，同时还有一个回调以及一个object可以传入（可选）

其返回值就是一个Handle，实现了接口IAsyncResult

```c#
public interface IAsyncResult
{
    object? AsyncState { get; }
}

public delegate void AsyncCallback(IAsyncResult ar);
```

其调用过程如下

```c#
try
{
    var handler = new Handler()
    handler.BeginDoStuff(arg, iar =>
    {
        try
        {
            Handler handler = (Handler)iar.AsyncState!;
            int i = handler.EndDoStuff(iar);
            Use(i);
        }
        catch (Exception e2)
        {
            ... // handle exceptions from EndDoStuff and Use
        }
    }, handler);
}
catch (Exception e)
{
    ... // handle exceptions thrown from the synchronous call to BeginDoStuff
}
```

看起来没什么问题（当然和await比显得非常臃肿）

但实际上可能存在一个问题，那就是堆栈溢出。异步操作并不总是异步完成的，它只是允许异步完成而已，更多的时候，它可能同步就完成了。此时Begin方法回立刻同步执行它的回调，继续逻辑，这时候如果在一个循环中不断的去调用这样一个“异步”方法，可能直接把堆栈打爆。

这时候有两种可行的方式来避免堆栈过深

1. 总是异步的执行回调，哪怕是同步完成的，但这样做很明显会有性能劣势
2. 提供一种新的机制，当方法同步完成时，不进入回调而允许用户自行继续处理逻辑

前者明显不太行，所以C#这边提供了一种新的机制，为接口IAsyncResult添加了2个新的属性

```c#
public interface IAsyncResult
{
    object? AsyncState { get; }

    bool IsCompleted { get; } //是否完成
    bool CompletedSynchronously { get; }//是否同步完成了
}
```

此时，我们就需要再进行异步操作的时候进行同步完成检查

```c#
try
{
    IAsyncResult ar = handler.BeginDoStuff(arg, iar =>
    {
        if (!iar.CompletedSynchronously)
        {
            try
            {
                Handler handler = (Handler)iar.AsyncState!;
                int i = handler.EndDoStuff(iar);
                Use(i);
            }
            catch (Exception e2)
            {
                ... // handle exceptions from EndDoStuff and Use
            }
        }
    }, handler);
    if (ar.CompletedSynchronously)
    {
        int i = handler.EndDoStuff(ar);
        Use(i);
    }
}
catch (Exception e)
{
    ... // handle exceptions that emerge synchronously from BeginDoStuff and possibly EndDoStuff/Use
}
```

呃，这个方法很好，很安全，就是...这是不是太麻烦了？

一个如此简单的异步操作（如今看来），又是try-catch，又是同步判断的，很难想象嵌套异步会复杂到什么程度！

## 基于事件的异步

.NET Framework 2.0提供了一些新的异步操作模式，一种基于事件的异步操作

比如上面的DoStuff操作需要修改为：

```c#
class Handler
{
    public int DoStuff(string arg);

    public void DoStuffAsync(string arg, object? userToken);
    public event DoStuffEventHandler? DoStuffCompleted;
}

public delegate void DoStuffEventHandler(object sender, DoStuffEventArgs e);

public class DoStuffEventArgs : AsyncCompletedEventArgs
{
    public DoStuffEventArgs(int result, Exception? error, bool canceled, object? userToken) :
        base(error, canceled, usertoken) => Result = result;

    public int Result { get; }
}
```

这个长得很像事件框架（不如说他就是....），你需要提前注册回调方法到DoStuffCompleted中，然后调用异步方法，异步方法结束时会触发对应的事件

看起来很美好，但是....如果每次开启异步操作前都要注册事件，而且一个异步操作可能在多个地方发起...光是想想就觉得很蛋疼

实际上他确实很蛋疼，所以这种模式几乎没有推广，很快就被淘汰了...

但是！虽然这个模式不太行，伴随它一起在.NET Framework 2.0引入的一个概念却非常重要，那就是———SynchronizationContext（同步上下文）

详细展开这个概念会花费非常多的笔墨（很多概念与Unity编程并没有直接关系），尽管多学习一些冷知识不是什么坏事，但为了避免陷入细节的汪洋，在这里我不会详细展开这个概念

简单来说，SC（同步上下文）需要配合Thread（多线程）来使用，废话，SC就是用于多线程直接交互...

你可以利用SC，把一个异步方法中抛入指定的上下文中执行

有点绕？请看一个UI按钮的例子...

如果我们点击按钮之后会进行一次非常非常慢的请求，怎么办？

很简单，我们可以开一个线程异步处理嘛

```c#
private void button1_Click(object sender, EventArgs e)
{
    //首先，我们开个线程，异步处理消息
    ThreadPool.QueueUserWorkItem(_ =>
    {
        //假设这是一个非常非常慢的消息处理
        string message = ComputeMessage();
        //等消息处理完，在设置按钮的文字
        button1.Text = message;
    });
}
```

很合理对吧？

合理个蛋！在这里我们开了一个新线程去处理消息，这没有问题，但是消息处理完怎么就能直接访问btn1呢？要知道我们点击事件可能处于A线程，消息处理可能处于B线程，不同线程怎么能这么简单的互相访问？

于是，SC需要登场了

我们改写一下这个方法

```c#
private void button1_Click(object sender, EventArgs e)
{
    //先获取当前同步上下文
    SynchronizationContext? sc = SynchronizationContext.Current;
    //进行异步操作
    ThreadPool.QueueUserWorkItem(_ =>
    {
        string message = ComputeMessage();
        //利用同步上下文，将回调发送到正确的线程中执行
        sc.Post(_ => {button1.text = message}, null);
    });
}
```

就是这么简单，万事大吉！

PS：这里我隐去了很多细节，尽可能不引入更多抽象的概念，也因如此，很多描述可能并不够准确

## 基于Task的异步

终于，在.Net Framework 4.0 我们引入了Task的概念...

然鹅，实际上...Task本身并没有异步的能力，他仅仅只是一个数据结构——某个异步操作结束后，异步的结果/相关信息会被存储到Task中

比如Task<bool>，它只是代表当某一个异步操作结束后，会把一个bool结果存放到Task内，经此而已

但是随着Task携带的某些特性，却能够彻底改变整个异步方法的流程

当然，说再多不如做一遍，所以我们干脆自己来实现一遍Task吧！（开玩笑...我们只能实现一个究极简略的mini版本）

```c#
class MyTask
{
    private bool _completed;
    private Exception? _error;
    private Action<MyTask>? _continuation;
    private ExecutionContext? _ec;
    ...
}
```































